<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<html>
<head>
<title>/home/alexander/haskell/project/neuroLiquid/app/Neuro.hs</title>
</head>
<head>
<link type='text/css' rel='stylesheet' href='liquid.css' />
</head>

<body>
<hr>
Put mouse over identifiers to see inferred types
<pre><span class=hs-linenum>  1: </span><a class=annot href="#"><span class=annottext>GHC.Types.Module</span><span class='hs-sel'>ï»¿</span></a><span class='hs-comment'>{-# LANGUAGE BangPatterns,RecordWildCards,FlexibleContexts,TypeFamilies #-}</span>
<span class=hs-linenum>  2: </span><span class='hs-comment'>{-# OPTIONS_GHC -Wno-deferred-type-errors #-}</span>
<span class=hs-linenum>  3: </span>
<span class=hs-linenum>  4: </span><span class='hs-keyword'>module</span> <span class='hs-conid'>Neuro</span> <span class='hs-keyword'>where</span>
<span class=hs-linenum>  5: </span>
<span class=hs-linenum>  6: </span><span class='hs-keyword'>{-@</span> <span class='hs-conid'>LIQUID</span> <span class='hs-str'>"--no-termination"</span> <span class='hs-keyword'>@-}</span>
<span class=hs-linenum>  7: </span><span class='hs-keyword'>{-@</span> <span class='hs-conid'>LIQUID</span> <span class='hs-str'>"--reflection"</span> <span class='hs-keyword'>@-}</span>
<span class=hs-linenum>  8: </span><span class='hs-keyword'>{-@</span> <span class='hs-conid'>LIQUID</span> <span class='hs-str'>"--no-total"</span> <span class='hs-keyword'>@-}</span>
<span class=hs-linenum>  9: </span>
<span class=hs-linenum> 10: </span><span class='hs-keyword'>import</span> <span class='hs-conid'>Codec.Compression.Zlib</span>     <span class='hs-layout'>(</span><span class='hs-varid'>compress</span><span class='hs-layout'>,</span> <span class='hs-varid'>decompress</span><span class='hs-layout'>)</span>
<span class=hs-linenum> 11: </span>
<span class=hs-linenum> 12: </span><span class='hs-keyword'>import</span> <span class='hs-conid'>Data.Binary</span>                <span class='hs-layout'>(</span><span class='hs-conid'>Binary</span><span class='hs-layout'>(</span><span class='hs-keyglyph'>..</span><span class='hs-layout'>)</span><span class='hs-layout'>,</span> <span class='hs-varid'>encode</span><span class='hs-layout'>,</span> <span class='hs-varid'>decode</span><span class='hs-layout'>)</span>
<span class=hs-linenum> 13: </span><span class='hs-keyword'>import</span> <span class='hs-conid'>Data.List</span>                  <span class='hs-layout'>(</span><span class='hs-varid'>foldl'</span><span class='hs-layout'>)</span>
<span class=hs-linenum> 14: </span><span class='hs-keyword'>import</span> <span class='hs-conid'>Foreign.Storable</span>           <span class='hs-layout'>(</span><span class='hs-conid'>Storable</span><span class='hs-layout'>)</span>
<span class=hs-linenum> 15: </span>
<span class=hs-linenum> 16: </span><span class='hs-keyword'>import</span> <span class='hs-keyword'>qualified</span> <span class='hs-conid'>Data.ByteString.Lazy</span>  <span class='hs-keyword'>as</span> <span class='hs-conid'>BS</span>
<span class=hs-linenum> 17: </span><span class='hs-keyword'>import</span> <span class='hs-keyword'>qualified</span> <span class='hs-conid'>Data.Vector</span>           <span class='hs-keyword'>as</span> <span class='hs-conid'>DV</span>
<span class=hs-linenum> 18: </span>      <span class='hs-layout'>(</span><span class='hs-conid'>Vector</span><span class='hs-layout'>,</span>
<span class=hs-linenum> 19: </span>      <span class='hs-varid'>toList</span><span class='hs-layout'>,</span>
<span class=hs-linenum> 20: </span>      <span class='hs-varid'>fromList</span><span class='hs-layout'>,</span>
<span class=hs-linenum> 21: </span>      <span class='hs-varid'>snoc</span><span class='hs-layout'>,</span><span class='hs-varid'>empty</span><span class='hs-layout'>,</span>
<span class=hs-linenum> 22: </span>      <span class='hs-varid'>foldl'</span><span class='hs-layout'>,</span>
<span class=hs-linenum> 23: </span>      <span class='hs-varid'>scanl</span><span class='hs-layout'>,</span><span class='hs-varid'>scanr</span><span class='hs-layout'>,</span>
<span class=hs-linenum> 24: </span>      <span class='hs-varid'>zipWith</span><span class='hs-layout'>,</span>
<span class=hs-linenum> 25: </span>      <span class='hs-varid'>tail</span><span class='hs-layout'>,</span><span class='hs-varid'>init</span><span class='hs-layout'>,</span><span class='hs-varid'>last</span><span class='hs-layout'>,</span><span class='hs-varid'>zip</span><span class='hs-layout'>,</span><span class='hs-varid'>map</span><span class='hs-layout'>,</span> <span class='hs-varid'>head</span><span class='hs-layout'>)</span>
<span class=hs-linenum> 26: </span><span class='hs-keyword'>import</span> <span class='hs-conid'>Numeric.LinearAlgebra</span>
<span class=hs-linenum> 27: </span>    <span class='hs-layout'>(</span> <span class='hs-layout'>(</span><span class='hs-cpp'>#&gt;</span><span class='hs-layout'>)</span><span class='hs-layout'>,</span>
<span class=hs-linenum> 28: </span>      <span class='hs-varid'>reshape</span><span class='hs-layout'>,</span>
<span class=hs-linenum> 29: </span>      <span class='hs-varid'>vector</span><span class='hs-layout'>,</span>
<span class=hs-linenum> 30: </span>      <span class='hs-varid'>cmap</span><span class='hs-layout'>,</span>
<span class=hs-linenum> 31: </span>      <span class='hs-layout'>(</span><span class='hs-varop'>&lt;.&gt;</span><span class='hs-layout'>)</span><span class='hs-layout'>,</span>
<span class=hs-linenum> 32: </span>      <span class='hs-layout'>(</span><span class='hs-varop'>&gt;&lt;</span><span class='hs-layout'>)</span><span class='hs-layout'>,</span>
<span class=hs-linenum> 33: </span>      <span class='hs-varid'>outer</span><span class='hs-layout'>,</span>
<span class=hs-linenum> 34: </span>      <span class='hs-varid'>vjoin</span><span class='hs-layout'>,</span>
<span class=hs-linenum> 35: </span>      <span class='hs-conid'>Element</span><span class='hs-layout'>,</span>
<span class=hs-linenum> 36: </span>      <span class='hs-conid'>Matrix</span><span class='hs-layout'>,</span>
<span class=hs-linenum> 37: </span>      <span class='hs-conid'>Container</span><span class='hs-layout'>,</span>
<span class=hs-linenum> 38: </span>      <span class='hs-conid'>Linear</span><span class='hs-layout'>(</span><span class='hs-varid'>scale</span><span class='hs-layout'>)</span><span class='hs-layout'>,</span>
<span class=hs-linenum> 39: </span>      <span class='hs-conid'>Numeric</span><span class='hs-layout'>,</span>
<span class=hs-linenum> 40: </span>      <span class='hs-conid'>RealOf</span><span class='hs-layout'>,</span>
<span class=hs-linenum> 41: </span>      <span class='hs-conid'>Transposable</span><span class='hs-layout'>(</span><span class='hs-varid'>tr</span><span class='hs-layout'>)</span><span class='hs-layout'>,</span>
<span class=hs-linenum> 42: </span>      <span class='hs-conid'>Normed</span><span class='hs-layout'>(</span><span class='hs-varid'>norm_2</span><span class='hs-layout'>)</span><span class='hs-layout'>,</span>
<span class=hs-linenum> 43: </span>      <span class='hs-conid'>Vector</span><span class='hs-layout'>)</span>
<span class=hs-linenum> 44: </span><span class='hs-keyword'>import</span> <span class='hs-conid'>System.Random.MWC</span>  <span class='hs-keyword'>as</span> <span class='hs-conid'>MWC</span>
<span class=hs-linenum> 45: </span>
<span class=hs-linenum> 46: </span><span class='hs-keyword'>newtype</span> <span class='hs-conid'>Network</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Network</span>
<span class=hs-linenum> 47: </span>                 <span class='hs-layout'>{</span> <span class='hs-varid'>matrices</span>   <span class='hs-keyglyph'>::</span> <span class='hs-conid'>DV.Vector</span> <span class='hs-layout'>(</span><span class='hs-conid'>Matrix</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span>
<span class=hs-linenum> 48: </span>                 <span class='hs-layout'>}</span> <span class='hs-keyword'>deriving</span> <span class='hs-conid'>Show</span>
<span class=hs-linenum> 49: </span>
<span class=hs-linenum> 50: </span><span class='hs-keyword'>instance</span> <a class=annot href="#"><span class=annottext>forall a .
(Internal.Matrix.Element&lt;[]&gt; a, Data.Binary.Class.Binary&lt;[]&gt; a) =&gt;
(Data.Binary.Class.Binary (Neuro.Network a))</span><span class='hs-layout'>(</span></a><span class='hs-conid'>Element</span> <span class='hs-varid'>a</span><span class='hs-layout'>,</span> <span class='hs-conid'>Binary</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-conid'>Binary</span> <span class='hs-layout'>(</span><span class='hs-conid'>Network</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span> <span class='hs-keyword'>where</span>
<span class=hs-linenum> 51: </span>  <a class=annot href="#"><span class=annottext>forall a .
(Internal.Matrix.Element&lt;[]&gt; a, Data.Binary.Class.Binary&lt;[]&gt; a) =&gt;
(Neuro.Network a) -&gt; (Data.Binary.Put.PutM ())</span><span class='hs-varid'>put</span></a> <span class='hs-layout'>(</span><span class='hs-conid'>Network</span> <span class='hs-varid'>ms</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>[(Internal.Matrix.Matrix a)] -&gt; (Data.Binary.Put.PutM ())</span><span class='hs-varid'>put</span></a> <span class='hs-varop'>.</span> <a class=annot href="#"><span class=annottext>{VV : forall a . (Data.Vector.Vector a) -&gt; [a] | VV == toList}</span><span class='hs-conid'>DV.toList</span></a> <span class='hs-varop'>$</span> <span class='hs-varid'>ms</span>
<span class=hs-linenum> 52: </span>  <a class=annot href="#"><span class=annottext>forall a .
(Internal.Matrix.Element&lt;[]&gt; a, Data.Binary.Class.Binary&lt;[]&gt; a) =&gt;
(Data.Binary.Get.Internal.Get (Neuro.Network a))</span><span class='hs-varid'>get</span></a> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>[(Internal.Matrix.Matrix a)] -&gt; (Neuro.Network a)</span><span class='hs-layout'>(</span></a><span class='hs-conid'>Network</span> <span class='hs-varop'>.</span> <a class=annot href="#"><span class=annottext>{VV : forall a .
      x1:[a] -&gt; {v : (Data.Vector.Vector a) | vlen v == len x1} | VV == fromList}</span><span class='hs-conid'>DV.fromList</span></a><span class='hs-layout'>)</span> <span class='hs-varop'>`fmap`</span> <a class=annot href="#"><span class=annottext>{v : (Data.Binary.Get.Internal.Get [(Internal.Matrix.Matrix a)]) | v == get}</span><span class='hs-varid'>get</span></a>                 
<span class=hs-linenum> 53: </span>
<span class=hs-linenum> 54: </span><span class='hs-keyword'>type</span> <span class='hs-conid'>ActivationFunction</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>a</span>
<span class=hs-linenum> 55: </span>
<span class=hs-linenum> 56: </span><span class='hs-keyword'>type</span> <span class='hs-conid'>ActivationFunctionDerivative</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>a</span>
<span class=hs-linenum> 57: </span>
<span class=hs-linenum> 58: </span><span class='hs-definition'>trainNTimes</span> <span class='hs-keyglyph'>::</span> <span class='hs-layout'>(</span><span class='hs-conid'>Floating</span> <span class='hs-layout'>(</span><span class='hs-conid'>Vector</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span><span class='hs-layout'>,</span> <span class='hs-conid'>Floating</span> <span class='hs-varid'>a</span><span class='hs-layout'>,</span> <span class='hs-conid'>Numeric</span> <span class='hs-varid'>a</span><span class='hs-layout'>,</span> <span class='hs-conid'>Num</span> <span class='hs-layout'>(</span><span class='hs-conid'>Vector</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span><span class='hs-layout'>,</span> <span class='hs-conid'>Container</span> <span class='hs-conid'>Vector</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-conid'>Int</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>ActivationFunction</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>ActivationFunctionDerivative</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Network</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Samples</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Network</span> <span class='hs-varid'>a</span>
<span class=hs-linenum> 59: </span><a class=annot href="#"><span class=annottext>forall a .
(GHC.Float.Floating&lt;[]&gt; (Data.Vector.Storable.Vector a), GHC.Float.Floating&lt;[]&gt; a, Internal.Numeric.Numeric&lt;[]&gt; a, GHC.Num.Num&lt;[]&gt; (Data.Vector.Storable.Vector a), Internal.Numeric.Container&lt;[]&gt; Data.Vector.Storable.Vector a) =&gt;
GHC.Types.Int -&gt; a -&gt; (a -&gt; a) -&gt; (a -&gt; a) -&gt; (Neuro.Network a) -&gt; [((Data.Vector.Storable.Vector a), (Data.Vector.Storable.Vector a))] -&gt; (Neuro.Network a)</span><span class='hs-definition'>trainNTimes</span></a> <a class=annot href="#"><span class=annottext>GHC.Types.Int</span><span class='hs-varid'>n</span></a> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>trainUntil</span> <a class=annot href="#"><span class=annottext>{v : GHC.Types.Bool | (v &lt;=&gt; k &gt; n)
                      &amp;&amp; v == &gt; k n}</span><span class='hs-layout'>(</span></a><span class='hs-keyglyph'>\</span><a class=annot href="#"><span class=annottext>GHC.Types.Int</span><span class='hs-varid'>k</span></a> <span class='hs-keyword'>_</span> <span class='hs-keyword'>_</span> <span class='hs-keyglyph'>-&gt;</span> <a class=annot href="#"><span class=annottext>{v : GHC.Types.Int | v == k}</span><span class='hs-varid'>k</span></a> <span class='hs-varop'>&gt;</span> <a class=annot href="#"><span class=annottext>{v : GHC.Types.Int | v == n}</span><span class='hs-varid'>n</span></a><span class='hs-layout'>)</span>
<span class=hs-linenum> 60: </span>
<span class=hs-linenum> 61: </span><span class='hs-definition'>trainUntil</span> <span class='hs-keyglyph'>::</span> <span class='hs-layout'>(</span><span class='hs-conid'>Floating</span> <span class='hs-layout'>(</span><span class='hs-conid'>Vector</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span><span class='hs-layout'>,</span> <span class='hs-conid'>Floating</span> <span class='hs-varid'>a</span><span class='hs-layout'>,</span> <span class='hs-conid'>Numeric</span> <span class='hs-varid'>a</span><span class='hs-layout'>,</span> <span class='hs-conid'>Num</span> <span class='hs-layout'>(</span><span class='hs-conid'>Vector</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span><span class='hs-layout'>,</span> <span class='hs-conid'>Container</span> <span class='hs-conid'>Vector</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-layout'>(</span><span class='hs-conid'>Int</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Network</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Samples</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Bool</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>ActivationFunction</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>ActivationFunctionDerivative</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Network</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Samples</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Network</span> <span class='hs-varid'>a</span>
<span class=hs-linenum> 62: </span><a class=annot href="#"><span class=annottext>forall a .
(GHC.Float.Floating&lt;[]&gt; (Data.Vector.Storable.Vector a), GHC.Float.Floating&lt;[]&gt; a, Internal.Numeric.Numeric&lt;[]&gt; a, GHC.Num.Num&lt;[]&gt; (Data.Vector.Storable.Vector a), Internal.Numeric.Container&lt;[]&gt; Data.Vector.Storable.Vector a) =&gt;
(GHC.Types.Int -&gt; (Neuro.Network a) -&gt; [((Data.Vector.Storable.Vector a), (Data.Vector.Storable.Vector a))] -&gt; GHC.Types.Bool) -&gt; a -&gt; (a -&gt; a) -&gt; (a -&gt; a) -&gt; (Neuro.Network a) -&gt; [((Data.Vector.Storable.Vector a), (Data.Vector.Storable.Vector a))] -&gt; (Neuro.Network a)</span><span class='hs-definition'>trainUntil</span></a> <a class=annot href="#"><span class=annottext>GHC.Types.Int -&gt; (Neuro.Network a) -&gt; [((Data.Vector.Storable.Vector a), (Data.Vector.Storable.Vector a))] -&gt; GHC.Types.Bool</span><span class='hs-varid'>pr</span></a> <a class=annot href="#"><span class=annottext>a</span><span class='hs-varid'>learningRate</span></a> <a class=annot href="#"><span class=annottext>a -&gt; a</span><span class='hs-varid'>act</span></a> <a class=annot href="#"><span class=annottext>a -&gt; a</span><span class='hs-varid'>act'</span></a> <a class=annot href="#"><span class=annottext>(Neuro.Network a)</span><span class='hs-varid'>net</span></a> <a class=annot href="#"><span class=annottext>[((Data.Vector.Storable.Vector a), (Data.Vector.Storable.Vector a))]</span><span class='hs-varid'>samples</span></a> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>(Neuro.Network a) -&gt; GHC.Types.Int -&gt; (Neuro.Network a)</span><span class='hs-varid'>go</span></a> <a class=annot href="#"><span class=annottext>{v : (Neuro.Network a) | v == net}</span><span class='hs-varid'>net</span></a> <a class=annot href="#"><span class=annottext>GHC.Types.Int</span><span class='hs-num'>0</span></a>
<span class=hs-linenum> 63: </span>  <span class='hs-keyword'>where</span> <a class=annot href="#"><span class=annottext>(Neuro.Network a) -&gt; GHC.Types.Int -&gt; (Neuro.Network a)</span><span class='hs-varid'>go</span></a> <a class=annot href="#"><span class=annottext>(Neuro.Network a)</span><span class='hs-varid'>n</span></a> <span class='hs-varop'>!</span><a class=annot href="#"><span class=annottext>GHC.Types.Int</span><span class='hs-varid'>k</span></a> <span class='hs-keyglyph'>|</span> <a class=annot href="#"><span class=annottext>GHC.Types.Bool</span><span class='hs-varid'>pr</span></a> <a class=annot href="#"><span class=annottext>{v : GHC.Types.Int | v == k}</span><span class='hs-varid'>k</span></a> <a class=annot href="#"><span class=annottext>{v : (Neuro.Network a) | v == n}</span><span class='hs-varid'>n</span></a> <a class=annot href="#"><span class=annottext>{v : [((Data.Vector.Storable.Vector a), (Data.Vector.Storable.Vector a))] | len v &gt;= 0
                                                                            &amp;&amp; v == samples}</span><span class='hs-varid'>samples</span></a> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>{v : (Neuro.Network a) | v == n}</span><span class='hs-varid'>n</span></a>
<span class=hs-linenum> 64: </span>                <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>      <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>case</span> <a class=annot href="#"><span class=annottext>{v : (Neuro.Network a) | v == backpropOnce learningRate act act' n samples}</span><span class='hs-varid'>backpropOnce</span></a> <a class=annot href="#"><span class=annottext>{VV : a | VV == learningRate}</span><span class='hs-varid'>learningRate</span></a> <a class=annot href="#"><span class=annottext>a -&gt; a</span><span class='hs-varid'>act</span></a> <a class=annot href="#"><span class=annottext>a -&gt; a</span><span class='hs-varid'>act'</span></a> <a class=annot href="#"><span class=annottext>{v : (Neuro.Network a) | v == n}</span><span class='hs-varid'>n</span></a> <a class=annot href="#"><span class=annottext>{v : [((Data.Vector.Storable.Vector a), (Data.Vector.Storable.Vector a))] | len v &gt;= 0
                                                                            &amp;&amp; v == samples}</span><span class='hs-varid'>samples</span></a> <span class='hs-keyword'>of</span>
<span class=hs-linenum> 65: </span>                                    <a class=annot href="#"><span class=annottext>{v : (Neuro.Network a) | v == backpropOnce learningRate act act' n samples}</span><span class='hs-varid'>n'</span></a> <span class='hs-keyglyph'>-&gt;</span> <a class=annot href="#"><span class=annottext>(Neuro.Network a) -&gt; GHC.Types.Int -&gt; (Neuro.Network a)</span><span class='hs-varid'>go</span></a> <a class=annot href="#"><span class=annottext>{v : (Neuro.Network a) | v == backpropOnce learningRate act act' n samples
                         &amp;&amp; v == n'}</span><span class='hs-varid'>n'</span></a> <a class=annot href="#"><span class=annottext>GHC.Types.Int</span><span class='hs-layout'>(</span></a><a class=annot href="#"><span class=annottext>{v : GHC.Types.Int | v == k}</span><span class='hs-varid'>k</span></a><span class='hs-varop'>+</span><a class=annot href="#"><span class=annottext>GHC.Types.Int</span><span class='hs-num'>1</span></a><span class='hs-layout'>)</span>
<span class=hs-linenum> 66: </span>
<span class=hs-linenum> 67: </span><span class='hs-definition'>createNetwork</span> <span class='hs-keyglyph'>::</span> <span class='hs-layout'>(</span><span class='hs-conid'>Variate</span> <span class='hs-varid'>a</span><span class='hs-layout'>,</span> <span class='hs-conid'>Storable</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-conid'>Int</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Int</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Int</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>IO</span> <span class='hs-layout'>(</span><span class='hs-conid'>Network</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span>
<span class=hs-linenum> 68: </span><a class=annot href="#"><span class=annottext>forall a .
(System.Random.MWC.Variate&lt;[]&gt; a, Foreign.Storable.Storable&lt;[]&gt; a) =&gt;
GHC.Types.Int -&gt; [GHC.Types.Int] -&gt; GHC.Types.Int -&gt; (GHC.Types.IO (Neuro.Network a))</span><span class='hs-definition'>createNetwork</span></a> <a class=annot href="#"><span class=annottext>GHC.Types.Int</span><span class='hs-varid'>nInputs</span></a> <a class=annot href="#"><span class=annottext>[GHC.Types.Int]</span><span class='hs-varid'>hiddens</span></a> <a class=annot href="#"><span class=annottext>GHC.Types.Int</span><span class='hs-varid'>nOutputs</span></a> <span class='hs-keyglyph'>=</span>
<span class=hs-linenum> 69: </span>  <a class=annot href="#"><span class=annottext>(GHC.Types.IO (Data.Vector.Vector (Internal.Matrix.Matrix a))) -&gt; (GHC.Types.IO (Neuro.Network a))</span><span class='hs-varid'>fmap</span></a> <span class='hs-conid'>Network</span> <span class='hs-varop'>$</span> <a class=annot href="#"><span class=annottext>((System.Random.MWC.Gen (Control.Monad.Primitive.PrimState (GHC.ST.ST (GHC.Types.Any (TYPE 'GHC.Types.LiftedRep))))) -&gt; (GHC.ST.ST (GHC.Types.Any (TYPE 'GHC.Types.LiftedRep)) (Data.Vector.Vector (Internal.Matrix.Matrix a)))) -&gt; (GHC.Types.IO (Data.Vector.Vector (Internal.Matrix.Matrix a)))</span><span class='hs-varid'>withSystemRandom</span></a> <span class='hs-varop'>.</span> <a class=annot href="#"><span class=annottext>{VV : forall a b .
      ((System.Random.MWC.Gen (Control.Monad.Primitive.PrimState (GHC.ST.ST a))) -&gt; (GHC.ST.ST a b)) -&gt; (System.Random.MWC.Gen (Control.Monad.Primitive.PrimState (GHC.ST.ST a))) -&gt; (GHC.ST.ST a b) | VV == asGenST}</span><span class='hs-varid'>asGenST</span></a> <span class='hs-varop'>$</span> <a class=annot href="#"><span class=annottext>{v : (Data.Vector.Vector (Internal.Matrix.Matrix a)) | v == empty}</span><span class='hs-keyglyph'>\</span></a><a class=annot href="#"><span class=annottext>(System.Random.MWC.Gen (GHC.Types.Any (TYPE 'GHC.Types.LiftedRep)))</span><span class='hs-varid'>gen</span></a> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>go</span> <span class='hs-varid'>gen</span> <a class=annot href="#"><span class=annottext>{v : [(GHC.Types.Int, GHC.Types.Int)] | len v &gt;= 0
                                        &amp;&amp; v == dimensions}</span><span class='hs-varid'>dimensions</span></a> <a class=annot href="#"><span class=annottext>{VV : forall a .
      {v : (Data.Vector.Vector a) | v == empty} | VV == empty}</span><span class='hs-conid'>DV.empty</span></a>
<span class=hs-linenum> 70: </span>  <span class='hs-keyword'>where</span>
<span class=hs-linenum> 71: </span>        <a class=annot href="#"><span class=annottext>(System.Random.MWC.Gen (Control.Monad.Primitive.PrimState a)) -&gt; [(GHC.Types.Int, GHC.Types.Int)] -&gt; (Data.Vector.Vector (Internal.Matrix.Matrix b)) -&gt; a (Data.Vector.Vector (Internal.Matrix.Matrix b))</span><span class='hs-varid'>go</span></a> <span class='hs-keyword'>_</span> <span class='hs-conid'>[]</span> <span class='hs-varop'>!</span><a class=annot href="#"><span class=annottext>(Data.Vector.Vector (Internal.Matrix.Matrix a))</span><span class='hs-varid'>ms</span></a>         <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>{v : (GHC.Base.Monad a) | v == $p1PrimMonad
                          &amp;&amp; v == $dMonad_a7JV}</span><span class='hs-varid'>return</span></a> <a class=annot href="#"><span class=annottext>{v : (Data.Vector.Vector (Internal.Matrix.Matrix a)) | 0 &lt;= vlen v
                                                       &amp;&amp; v == ms}</span><span class='hs-varid'>ms</span></a>
<span class=hs-linenum> 72: </span>        <span class='hs-varid'>go</span> <span class='hs-varid'>gen</span> <span class='hs-layout'>(</span><span class='hs-layout'>(</span><span class='hs-varop'>!</span><span class='hs-varid'>n</span><span class='hs-layout'>,</span><span class='hs-varop'>!</span><span class='hs-varid'>m</span><span class='hs-layout'>)</span><span class='hs-conop'>:</span><span class='hs-varid'>ds</span><span class='hs-layout'>)</span> <span class='hs-varid'>ms</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span>
<span class=hs-linenum> 73: </span>          <span class='hs-varop'>!</span><a class=annot href="#"><span class=annottext>(Internal.Matrix.Matrix a)</span><span class='hs-varid'>mat</span></a> <span class='hs-keyglyph'>&lt;-</span> <a class=annot href="#"><span class=annottext>a (Internal.Matrix.Matrix b)</span><span class='hs-varid'>randomMat</span></a> <a class=annot href="#"><span class=annottext>{v : GHC.Types.Int | v == n}</span><span class='hs-varid'>n</span></a> <a class=annot href="#"><span class=annottext>{v : GHC.Types.Int | v == m}</span><span class='hs-varid'>m</span></a> <a class=annot href="#"><span class=annottext>(System.Random.MWC.Gen (Control.Monad.Primitive.PrimState a))</span><span class='hs-varid'>gen</span></a>
<span class=hs-linenum> 74: </span>          <a class=annot href="#"><span class=annottext>(System.Random.MWC.Gen (Control.Monad.Primitive.PrimState a)) -&gt; [(GHC.Types.Int, GHC.Types.Int)] -&gt; (Data.Vector.Vector (Internal.Matrix.Matrix b)) -&gt; a (Data.Vector.Vector (Internal.Matrix.Matrix b))</span><span class='hs-varid'>go</span></a> <a class=annot href="#"><span class=annottext>(System.Random.MWC.Gen (Control.Monad.Primitive.PrimState a))</span><span class='hs-varid'>gen</span></a> <a class=annot href="#"><span class=annottext>{v : [(GHC.Types.Int, GHC.Types.Int)] | len v &gt;= 0
                                        &amp;&amp; v == ds}</span><span class='hs-varid'>ds</span></a> <a class=annot href="#"><span class=annottext>(Data.Vector.Vector (Internal.Matrix.Matrix a))</span><span class='hs-layout'>(</span></a><a class=annot href="#"><span class=annottext>{v : (Data.Vector.Vector (Internal.Matrix.Matrix a)) | 0 &lt;= vlen v
                                                       &amp;&amp; v == ms}</span><span class='hs-varid'>ms</span></a> <span class='hs-varop'>`DV.snoc`</span> <a class=annot href="#"><span class=annottext>{v : (Internal.Matrix.Matrix a) | v == mat}</span><span class='hs-varid'>mat</span></a><span class='hs-layout'>)</span>
<span class=hs-linenum> 75: </span>        <a class=annot href="#"><span class=annottext>forall a b .
(Foreign.Storable.Storable&lt;[]&gt; b, Control.Monad.Primitive.PrimMonad&lt;[]&gt; a, System.Random.MWC.Variate&lt;[]&gt; b) =&gt;
GHC.Types.Int -&gt; GHC.Types.Int -&gt; (System.Random.MWC.Gen (Control.Monad.Primitive.PrimState a)) -&gt; a (Internal.Matrix.Matrix b)</span><span class='hs-varid'>randomMat</span></a> <a class=annot href="#"><span class=annottext>GHC.Types.Int</span><span class='hs-varid'>n</span></a> <a class=annot href="#"><span class=annottext>GHC.Types.Int</span><span class='hs-varid'>m</span></a> <a class=annot href="#"><span class=annottext>(System.Random.MWC.Gen (Control.Monad.Primitive.PrimState a))</span><span class='hs-varid'>g</span></a> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>(Data.Vector.Storable.Vector a) -&gt; (Internal.Matrix.Matrix a)</span><span class='hs-varid'>reshape</span></a> <a class=annot href="#"><span class=annottext>{v : GHC.Types.Int | v == m}</span><span class='hs-varid'>m</span></a> <span class='hs-varop'>`fmap`</span> <a class=annot href="#"><span class=annottext>a (Data.Vector.Storable.Vector b)</span><span class='hs-varid'>uniformVector</span></a> <a class=annot href="#"><span class=annottext>{v : (System.Random.MWC.Gen (Control.Monad.Primitive.PrimState a)) | v == g}</span><span class='hs-varid'>g</span></a> <a class=annot href="#"><span class=annottext>{v : GHC.Types.Int | v == n * m
                     &amp;&amp; v == * n m}</span><span class='hs-layout'>(</span></a><a class=annot href="#"><span class=annottext>{v : GHC.Types.Int | v == n}</span><span class='hs-varid'>n</span></a><span class='hs-varop'>*</span><a class=annot href="#"><span class=annottext>{v : GHC.Types.Int | v == m}</span><span class='hs-varid'>m</span></a><span class='hs-layout'>)</span>
<span class=hs-linenum> 76: </span>        <a class=annot href="#"><span class=annottext>[(GHC.Types.Int, GHC.Types.Int)]</span><span class='hs-varid'>dimensions</span></a>      <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>x1:[GHC.Types.Int] -&gt; {v : [(GHC.Types.Int, GHC.Types.Int)] | len v &lt;= len x1}</span><span class='hs-varid'>zip</span></a> <a class=annot href="#"><span class=annottext>[GHC.Types.Int]</span><span class='hs-layout'>(</span></a><a class=annot href="#"><span class=annottext>{v : [GHC.Types.Int] | len v &gt;= 0
                       &amp;&amp; v == hiddens}</span><span class='hs-varid'>hiddens</span></a> <span class='hs-varop'>++</span> <a class=annot href="#"><span class=annottext>{v : [GHC.Types.Int] | head v == nOutputs
                       &amp;&amp; lqdc##$select v == nOutputs}</span><span class='hs-keyglyph'>[</span></a><a class=annot href="#"><span class=annottext>{v : GHC.Types.Int | v == nOutputs}</span><span class='hs-varid'>nOutputs</span></a><span class='hs-keyglyph'>]</span><span class='hs-layout'>)</span> <span class='hs-varop'>$</span>
<span class=hs-linenum> 77: </span>                              <a class=annot href="#"><span class=annottext>{v : [GHC.Types.Int] | tail v == hiddens
                       &amp;&amp; lqdc##$select v == hiddens
                       &amp;&amp; len v == 1 + len hiddens}</span><span class='hs-layout'>(</span></a><a class=annot href="#"><span class=annottext>{v : GHC.Types.Int | v == nInputs}</span><span class='hs-varid'>nInputs</span></a><span class='hs-varop'>+</span><a class=annot href="#"><span class=annottext>GHC.Types.Int</span><span class='hs-num'>1</span></a> <span class='hs-conop'>:</span> <a class=annot href="#"><span class=annottext>{v : [GHC.Types.Int] | len v &gt;= 0
                       &amp;&amp; v == hiddens}</span><span class='hs-varid'>hiddens</span></a><span class='hs-layout'>)</span>
<span class=hs-linenum> 78: </span>
<span class=hs-linenum> 79: </span><span class='hs-definition'>fromWeightMatrices</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Storable</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-conid'>DV.Vector</span> <span class='hs-layout'>(</span><span class='hs-conid'>Matrix</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Network</span> <span class='hs-varid'>a</span>
<span class=hs-linenum> 80: </span><a class=annot href="#"><span class=annottext>forall a .
(Foreign.Storable.Storable&lt;[]&gt; a) =&gt;
(Data.Vector.Vector (Internal.Matrix.Matrix a)) -&gt; (Neuro.Network a)</span><span class='hs-definition'>fromWeightMatrices</span></a> <a class=annot href="#"><span class=annottext>(Data.Vector.Vector (Internal.Matrix.Matrix a))</span><span class='hs-varid'>ws</span></a> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Network</span> <span class='hs-varid'>ws</span>
<span class=hs-linenum> 81: </span>
<span class=hs-linenum> 82: </span><span class='hs-definition'>output</span> <span class='hs-keyglyph'>::</span> <span class='hs-layout'>(</span><span class='hs-conid'>Floating</span> <span class='hs-layout'>(</span><span class='hs-conid'>Vector</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span><span class='hs-layout'>,</span> <span class='hs-conid'>Numeric</span> <span class='hs-varid'>a</span><span class='hs-layout'>,</span> <span class='hs-conid'>Storable</span> <span class='hs-varid'>a</span><span class='hs-layout'>,</span> <span class='hs-conid'>Num</span> <span class='hs-layout'>(</span><span class='hs-conid'>Vector</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-conid'>Network</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>ActivationFunction</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Vector</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Vector</span> <span class='hs-varid'>a</span>
<span class=hs-linenum> 83: </span><a class=annot href="#"><span class=annottext>forall a .
(GHC.Float.Floating&lt;[]&gt; (Data.Vector.Storable.Vector a), Internal.Numeric.Numeric&lt;[]&gt; a, Foreign.Storable.Storable&lt;[]&gt; a, GHC.Num.Num&lt;[]&gt; (Data.Vector.Storable.Vector a)) =&gt;
(Neuro.Network a) -&gt; (a -&gt; a) -&gt; (Data.Vector.Storable.Vector a) -&gt; (Data.Vector.Storable.Vector a)</span><span class='hs-definition'>output</span></a> <span class='hs-layout'>(</span><span class='hs-conid'>Network</span><span class='hs-layout'>{</span><span class='hs-keyglyph'>..</span><span class='hs-layout'>}</span><span class='hs-layout'>)</span> <a class=annot href="#"><span class=annottext>a -&gt; a</span><span class='hs-varid'>act</span></a> <a class=annot href="#"><span class=annottext>(Data.Vector.Storable.Vector a)</span><span class='hs-varid'>input</span></a> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>(Data.Vector.Vector (Internal.Matrix.Matrix a))</span><span class='hs-conid'>DV.foldl'</span></a> <a class=annot href="#"><span class=annottext>(Data.Vector.Storable.Vector a) -&gt; (Internal.Matrix.Matrix a) -&gt; (Data.Vector.Storable.Vector a)</span><span class='hs-varid'>f</span></a> <a class=annot href="#"><span class=annottext>(Data.Vector.Storable.Vector a)</span><span class='hs-layout'>(</span></a><span class='hs-varid'>vjoin</span> <a class=annot href="#"><span class=annottext>{v : [(Data.Vector.Storable.Vector a)] | head v == input
                                         &amp;&amp; lqdc##$select v == input}</span><span class='hs-keyglyph'>[</span></a><a class=annot href="#"><span class=annottext>{v : (Data.Vector.Storable.Vector a) | v == input}</span><span class='hs-varid'>input</span></a><span class='hs-layout'>,</span> <a class=annot href="#"><span class=annottext>(Data.Vector.Storable.Vector a)</span><span class='hs-num'>1</span></a><span class='hs-keyglyph'>]</span><span class='hs-layout'>)</span> <span class='hs-varid'>matrices</span>
<span class=hs-linenum> 84: </span>  <span class='hs-keyword'>where</span> <a class=annot href="#"><span class=annottext>(Data.Vector.Storable.Vector a) -&gt; (Internal.Matrix.Matrix a) -&gt; (Data.Vector.Storable.Vector a)</span><span class='hs-varid'>f</span></a> <span class='hs-varop'>!</span><a class=annot href="#"><span class=annottext>(Data.Vector.Storable.Vector a)</span><span class='hs-varid'>inp</span></a> <a class=annot href="#"><span class=annottext>(Internal.Matrix.Matrix a)</span><span class='hs-varid'>m</span></a> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>(Data.Vector.Storable.Vector a) -&gt; (Data.Vector.Storable.Vector a)</span><span class='hs-varid'>cmap</span></a> <a class=annot href="#"><span class=annottext>a -&gt; a</span><span class='hs-varid'>act</span></a> <span class='hs-varop'>$</span> <a class=annot href="#"><span class=annottext>{v : (Internal.Matrix.Matrix a) | v == m}</span><span class='hs-varid'>m</span></a> <span class='hs-cpp'>#&gt;</span> <a class=annot href="#"><span class=annottext>{v : (Data.Vector.Storable.Vector a) | v == inp}</span><span class='hs-varid'>inp</span></a>
<span class=hs-linenum> 85: </span>
<span class=hs-linenum> 86: </span><span class='hs-definition'>outputs</span> <span class='hs-keyglyph'>::</span> <span class='hs-layout'>(</span><span class='hs-conid'>Floating</span> <span class='hs-layout'>(</span><span class='hs-conid'>Vector</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span><span class='hs-layout'>,</span> <span class='hs-conid'>Numeric</span> <span class='hs-varid'>a</span><span class='hs-layout'>,</span> <span class='hs-conid'>Storable</span> <span class='hs-varid'>a</span><span class='hs-layout'>,</span> <span class='hs-conid'>Num</span> <span class='hs-layout'>(</span><span class='hs-conid'>Vector</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-conid'>Network</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>ActivationFunction</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Vector</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>DV.Vector</span> <span class='hs-layout'>(</span><span class='hs-conid'>Vector</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span>
<span class=hs-linenum> 87: </span><a class=annot href="#"><span class=annottext>forall a .
(GHC.Float.Floating&lt;[]&gt; (Data.Vector.Storable.Vector a), Internal.Numeric.Numeric&lt;[]&gt; a, Foreign.Storable.Storable&lt;[]&gt; a, GHC.Num.Num&lt;[]&gt; (Data.Vector.Storable.Vector a)) =&gt;
(Neuro.Network a) -&gt; (a -&gt; a) -&gt; (Data.Vector.Storable.Vector a) -&gt; (Data.Vector.Vector (Data.Vector.Storable.Vector a))</span><span class='hs-definition'>outputs</span></a> <span class='hs-layout'>(</span><span class='hs-conid'>Network</span><span class='hs-layout'>{</span><span class='hs-keyglyph'>..</span><span class='hs-layout'>}</span><span class='hs-layout'>)</span> <a class=annot href="#"><span class=annottext>a -&gt; a</span><span class='hs-varid'>act</span></a> <a class=annot href="#"><span class=annottext>(Data.Vector.Storable.Vector a)</span><span class='hs-varid'>input</span></a> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>(Data.Vector.Vector (Internal.Matrix.Matrix a))</span><span class='hs-conid'>DV.scanl</span></a> <a class=annot href="#"><span class=annottext>(Data.Vector.Storable.Vector a) -&gt; (Internal.Matrix.Matrix a) -&gt; (Data.Vector.Storable.Vector a)</span><span class='hs-varid'>f</span></a> <a class=annot href="#"><span class=annottext>(Data.Vector.Storable.Vector a)</span><span class='hs-layout'>(</span></a><span class='hs-varid'>vjoin</span> <a class=annot href="#"><span class=annottext>{v : [(Data.Vector.Storable.Vector a)] | head v == input
                                         &amp;&amp; lqdc##$select v == input}</span><span class='hs-keyglyph'>[</span></a><a class=annot href="#"><span class=annottext>{v : (Data.Vector.Storable.Vector a) | v == input}</span><span class='hs-varid'>input</span></a><span class='hs-layout'>,</span> <a class=annot href="#"><span class=annottext>(Data.Vector.Storable.Vector a)</span><span class='hs-num'>1</span></a><span class='hs-keyglyph'>]</span><span class='hs-layout'>)</span> <span class='hs-varid'>matrices</span>
<span class=hs-linenum> 88: </span>  <span class='hs-keyword'>where</span> <a class=annot href="#"><span class=annottext>(Data.Vector.Storable.Vector a) -&gt; (Internal.Matrix.Matrix a) -&gt; (Data.Vector.Storable.Vector a)</span><span class='hs-varid'>f</span></a> <span class='hs-varop'>!</span><a class=annot href="#"><span class=annottext>(Data.Vector.Storable.Vector a)</span><span class='hs-varid'>inp</span></a> <a class=annot href="#"><span class=annottext>(Internal.Matrix.Matrix a)</span><span class='hs-varid'>m</span></a> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>(Data.Vector.Storable.Vector a) -&gt; (Data.Vector.Storable.Vector a)</span><span class='hs-varid'>cmap</span></a> <a class=annot href="#"><span class=annottext>a -&gt; a</span><span class='hs-varid'>act</span></a> <span class='hs-varop'>$</span> <a class=annot href="#"><span class=annottext>{v : (Internal.Matrix.Matrix a) | v == m}</span><span class='hs-varid'>m</span></a> <span class='hs-cpp'>#&gt;</span> <a class=annot href="#"><span class=annottext>{v : (Data.Vector.Storable.Vector a) | v == inp}</span><span class='hs-varid'>inp</span></a>
<span class=hs-linenum> 89: </span>
<span class=hs-linenum> 90: </span><span class='hs-definition'>deltas</span> <span class='hs-keyglyph'>::</span> <span class='hs-layout'>(</span><span class='hs-conid'>Floating</span> <span class='hs-layout'>(</span><span class='hs-conid'>Vector</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span><span class='hs-layout'>,</span> <span class='hs-conid'>Floating</span> <span class='hs-varid'>a</span><span class='hs-layout'>,</span> <span class='hs-conid'>Numeric</span> <span class='hs-varid'>a</span><span class='hs-layout'>,</span> <span class='hs-conid'>Container</span> <span class='hs-conid'>Vector</span> <span class='hs-varid'>a</span><span class='hs-layout'>,</span> <span class='hs-conid'>Num</span> <span class='hs-layout'>(</span><span class='hs-conid'>Vector</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-conid'>Network</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>ActivationFunctionDerivative</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>DV.Vector</span> <span class='hs-layout'>(</span><span class='hs-conid'>Vector</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Vector</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>DV.Vector</span> <span class='hs-layout'>(</span><span class='hs-conid'>Matrix</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span>
<span class=hs-linenum> 91: </span><a class=annot href="#"><span class=annottext>forall a .
(GHC.Float.Floating&lt;[]&gt; (Data.Vector.Storable.Vector a), GHC.Float.Floating&lt;[]&gt; a, Internal.Numeric.Numeric&lt;[]&gt; a, Internal.Numeric.Container&lt;[]&gt; Data.Vector.Storable.Vector a, GHC.Num.Num&lt;[]&gt; (Data.Vector.Storable.Vector a)) =&gt;
(Neuro.Network a) -&gt; (a -&gt; a) -&gt; (Data.Vector.Vector (Data.Vector.Storable.Vector a)) -&gt; (Data.Vector.Storable.Vector a) -&gt; (Data.Vector.Vector (Internal.Matrix.Matrix a))</span><span class='hs-definition'>deltas</span></a> <span class='hs-layout'>(</span><span class='hs-conid'>Network</span><span class='hs-layout'>{</span><span class='hs-keyglyph'>..</span><span class='hs-layout'>}</span><span class='hs-layout'>)</span> <a class=annot href="#"><span class=annottext>a -&gt; a</span><span class='hs-varid'>act'</span></a> <a class=annot href="#"><span class=annottext>(Data.Vector.Vector (Data.Vector.Storable.Vector a))</span><span class='hs-varid'>os</span></a> <a class=annot href="#"><span class=annottext>(Data.Vector.Storable.Vector a)</span><span class='hs-varid'>expected</span></a> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>{VV : forall a b c .
      (a -&gt; b -&gt; c) -&gt; (Data.Vector.Vector a) -&gt; (Data.Vector.Vector b) -&gt; (Data.Vector.Vector c) | VV == zipWith}</span><span class='hs-conid'>DV.zipWith</span></a> <a class=annot href="#"><span class=annottext>(Data.Vector.Storable.Vector a) -&gt; (Data.Vector.Storable.Vector a) -&gt; (Internal.Matrix.Matrix a)</span><span class='hs-varid'>outer</span></a> <a class=annot href="#"><span class=annottext>(Data.Vector.Vector (Data.Vector.Storable.Vector a))</span><span class='hs-layout'>(</span></a><span class='hs-conid'>DV.tail</span> <a class=annot href="#"><span class=annottext>{v : (Data.Vector.Vector (Data.Vector.Storable.Vector a)) | 0 &lt;= vlen v}</span><span class='hs-varid'>ds</span></a><span class='hs-layout'>)</span> <a class=annot href="#"><span class=annottext>{v : (Data.Vector.Vector (Data.Vector.Storable.Vector a)) | v == init os}</span><span class='hs-layout'>(</span></a><span class='hs-conid'>DV.init</span> <a class=annot href="#"><span class=annottext>{v : (Data.Vector.Vector (Data.Vector.Storable.Vector a)) | 0 &lt;= vlen v
                                                            &amp;&amp; v == os}</span><span class='hs-varid'>os</span></a><span class='hs-layout'>)</span>
<span class=hs-linenum> 92: </span>  <span class='hs-keyword'>where</span> <span class='hs-varop'>!</span><span class='hs-varid'>dl</span> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>(Data.Vector.Storable.Vector a)</span><span class='hs-layout'>(</span></a><a class=annot href="#"><span class=annottext>{v : (Data.Vector.Storable.Vector a) | v == last os}</span><span class='hs-conid'>DV.last</span></a> <a class=annot href="#"><span class=annottext>{v : (Data.Vector.Vector (Data.Vector.Storable.Vector a)) | 0 &lt;= vlen v
                                                            &amp;&amp; v == os}</span><span class='hs-varid'>os</span></a> <span class='hs-comment'>-</span> <a class=annot href="#"><span class=annottext>{v : (Data.Vector.Storable.Vector a) | v == expected}</span><span class='hs-varid'>expected</span></a><span class='hs-layout'>)</span> <span class='hs-varop'>*</span> <a class=annot href="#"><span class=annottext>(Data.Vector.Storable.Vector a)</span><span class='hs-layout'>(</span></a><a class=annot href="#"><span class=annottext>(Data.Vector.Storable.Vector a) -&gt; (Data.Vector.Storable.Vector a)</span><span class='hs-varid'>deriv</span></a> <span class='hs-varop'>$</span> <a class=annot href="#"><span class=annottext>{v : (Data.Vector.Storable.Vector a) | v == last os}</span><span class='hs-conid'>DV.last</span></a> <a class=annot href="#"><span class=annottext>{v : (Data.Vector.Vector (Data.Vector.Storable.Vector a)) | 0 &lt;= vlen v
                                                            &amp;&amp; v == os}</span><span class='hs-varid'>os</span></a><span class='hs-layout'>)</span>
<span class=hs-linenum> 93: </span>        <span class='hs-varop'>!</span><span class='hs-varid'>ds</span> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>(Data.Vector.Vector (Data.Vector.Storable.Vector a))</span><span class='hs-conid'>DV.scanr</span></a> <a class=annot href="#"><span class=annottext>((Data.Vector.Storable.Vector a), (Internal.Matrix.Matrix a)) -&gt; (Data.Vector.Storable.Vector a) -&gt; (Data.Vector.Storable.Vector a)</span><span class='hs-varid'>f</span></a> <a class=annot href="#"><span class=annottext>(Data.Vector.Storable.Vector a)</span><span class='hs-varid'>dl</span></a> <a class=annot href="#"><span class=annottext>(Data.Vector.Vector ((Data.Vector.Storable.Vector a), (Internal.Matrix.Matrix a)))</span><span class='hs-layout'>(</span></a><span class='hs-conid'>DV.zip</span> <a class=annot href="#"><span class=annottext>{v : (Data.Vector.Vector (Data.Vector.Storable.Vector a)) | 0 &lt;= vlen v
                                                            &amp;&amp; v == os}</span><span class='hs-varid'>os</span></a> <span class='hs-varid'>matrices</span><span class='hs-layout'>)</span>
<span class=hs-linenum> 94: </span>        <a class=annot href="#"><span class=annottext>((Data.Vector.Storable.Vector a), (Internal.Matrix.Matrix a)) -&gt; (Data.Vector.Storable.Vector a) -&gt; (Data.Vector.Storable.Vector a)</span><span class='hs-varid'>f</span></a> <span class='hs-layout'>(</span><span class='hs-varop'>!</span><span class='hs-varid'>o</span><span class='hs-layout'>,</span> <span class='hs-varid'>m</span><span class='hs-layout'>)</span> <span class='hs-varop'>!</span><a class=annot href="#"><span class=annottext>(Data.Vector.Storable.Vector a)</span><span class='hs-varid'>del</span></a> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>(Data.Vector.Storable.Vector a)</span><span class='hs-varid'>deriv</span></a> <a class=annot href="#"><span class=annottext>{v : (Data.Vector.Storable.Vector a) | v == o}</span><span class='hs-varid'>o</span></a> <span class='hs-varop'>*</span> <a class=annot href="#"><span class=annottext>(Data.Vector.Storable.Vector a)</span><span class='hs-layout'>(</span></a><a class=annot href="#"><span class=annottext>{v : (Internal.Matrix.Matrix a) | v == tr m}</span><span class='hs-varid'>tr</span></a> <a class=annot href="#"><span class=annottext>{v : (Internal.Matrix.Matrix a) | v == m}</span><span class='hs-varid'>m</span></a> <span class='hs-cpp'>#&gt;</span> <a class=annot href="#"><span class=annottext>{v : (Data.Vector.Storable.Vector a) | v == del}</span><span class='hs-varid'>del</span></a><span class='hs-layout'>)</span>
<span class=hs-linenum> 95: </span>        <a class=annot href="#"><span class=annottext>(Data.Vector.Storable.Vector a) -&gt; (Data.Vector.Storable.Vector a)</span><span class='hs-varid'>deriv</span></a> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>(Data.Vector.Storable.Vector a) -&gt; (Data.Vector.Storable.Vector a)</span><span class='hs-varid'>cmap</span></a> <a class=annot href="#"><span class=annottext>a -&gt; a</span><span class='hs-varid'>act'</span></a>
<span class=hs-linenum> 96: </span>
<span class=hs-linenum> 97: </span><span class='hs-definition'>updateNetwork</span> <span class='hs-keyglyph'>::</span> <span class='hs-layout'>(</span><span class='hs-conid'>Floating</span> <span class='hs-layout'>(</span><span class='hs-conid'>Vector</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span><span class='hs-layout'>,</span> <span class='hs-conid'>Floating</span> <span class='hs-varid'>a</span><span class='hs-layout'>,</span> <span class='hs-conid'>Numeric</span> <span class='hs-varid'>a</span><span class='hs-layout'>,</span> <span class='hs-conid'>Storable</span> <span class='hs-varid'>a</span><span class='hs-layout'>,</span> <span class='hs-conid'>Num</span> <span class='hs-layout'>(</span><span class='hs-conid'>Vector</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span><span class='hs-layout'>,</span> <span class='hs-conid'>Container</span> <span class='hs-conid'>Vector</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>ActivationFunction</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>ActivationFunctionDerivative</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Network</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Sample</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Network</span> <span class='hs-varid'>a</span>
<span class=hs-linenum> 98: </span><a class=annot href="#"><span class=annottext>forall a .
(GHC.Float.Floating&lt;[]&gt; (Data.Vector.Storable.Vector a), GHC.Float.Floating&lt;[]&gt; a, Internal.Numeric.Numeric&lt;[]&gt; a, Foreign.Storable.Storable&lt;[]&gt; a, GHC.Num.Num&lt;[]&gt; (Data.Vector.Storable.Vector a), Internal.Numeric.Container&lt;[]&gt; Data.Vector.Storable.Vector a) =&gt;
a -&gt; (a -&gt; a) -&gt; (a -&gt; a) -&gt; (Neuro.Network a) -&gt; ((Data.Vector.Storable.Vector a), (Data.Vector.Storable.Vector a)) -&gt; (Neuro.Network a)</span><span class='hs-definition'>updateNetwork</span></a> <a class=annot href="#"><span class=annottext>a</span><span class='hs-varid'>alpha</span></a> <a class=annot href="#"><span class=annottext>a -&gt; a</span><span class='hs-varid'>act</span></a> <a class=annot href="#"><span class=annottext>a -&gt; a</span><span class='hs-varid'>act'</span></a> <a class=annot href="#"><span class=annottext>(Neuro.Network a)</span><span class='hs-varid'>n</span></a><span class='hs-keyglyph'>@</span><span class='hs-layout'>(</span><span class='hs-conid'>Network</span><span class='hs-layout'>{</span><span class='hs-keyglyph'>..</span><span class='hs-layout'>}</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-varid'>input</span><span class='hs-layout'>,</span> <span class='hs-varid'>expectedOutput</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>v_B1:(Data.Vector.Vector (Internal.Matrix.Matrix a)) -&gt; {VV : (Neuro.Network a) | VV ~~ v_B1}</span><span class='hs-conid'>Network</span></a> <span class='hs-varop'>$</span> <a class=annot href="#"><span class=annottext>(Data.Vector.Vector (Internal.Matrix.Matrix a))</span><span class='hs-conid'>DV.zipWith</span></a> <a class=annot href="#"><span class=annottext>x1:(Internal.Matrix.Matrix a) -&gt; x2:(Internal.Matrix.Matrix a) -&gt; {v : (Internal.Matrix.Matrix a) | v == x1 + x2}</span><span class='hs-layout'>(</span></a><span class='hs-varop'>+</span><span class='hs-layout'>)</span> <span class='hs-varid'>matrices</span> <a class=annot href="#"><span class=annottext>{v : (Data.Vector.Vector (Internal.Matrix.Matrix a)) | 0 &lt;= vlen v}</span><span class='hs-varid'>corr</span></a>
<span class=hs-linenum> 99: </span>    <span class='hs-keyword'>where</span> <span class='hs-varop'>!</span><span class='hs-varid'>xs</span> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>{v : (Data.Vector.Vector (Data.Vector.Storable.Vector a)) | v == outputs n act input}</span><span class='hs-varid'>outputs</span></a> <a class=annot href="#"><span class=annottext>{v : (Neuro.Network a) | v == n}</span><span class='hs-varid'>n</span></a> <a class=annot href="#"><span class=annottext>a -&gt; a</span><span class='hs-varid'>act</span></a> <a class=annot href="#"><span class=annottext>{v : (Data.Vector.Storable.Vector a) | v == input}</span><span class='hs-varid'>input</span></a>
<span class=hs-linenum>100: </span>          <span class='hs-varop'>!</span><span class='hs-varid'>ds</span> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>(Data.Vector.Vector (Internal.Matrix.Matrix a))</span><span class='hs-varid'>deltas</span></a> <a class=annot href="#"><span class=annottext>{v : (Neuro.Network a) | v == n}</span><span class='hs-varid'>n</span></a> <a class=annot href="#"><span class=annottext>a -&gt; a</span><span class='hs-varid'>act'</span></a> <a class=annot href="#"><span class=annottext>{v : (Data.Vector.Vector (Data.Vector.Storable.Vector a)) | v == outputs n act input
                                                            &amp;&amp; 0 &lt;= vlen v}</span><span class='hs-varid'>xs</span></a> <a class=annot href="#"><span class=annottext>{v : (Data.Vector.Storable.Vector a) | v == expectedOutput}</span><span class='hs-varid'>expectedOutput</span></a>
<span class=hs-linenum>101: </span>          <span class='hs-varop'>!</span><span class='hs-varid'>corr</span> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>(Data.Vector.Vector (Internal.Matrix.Matrix a))</span><span class='hs-conid'>DV.map</span></a> <a class=annot href="#"><span class=annottext>(Internal.Matrix.Matrix a) -&gt; (Internal.Matrix.Matrix a)</span><span class='hs-layout'>(</span></a><span class='hs-varid'>scale</span> <a class=annot href="#"><span class=annottext>{VV : a | VV == (-alpha)
          &amp;&amp; VV == negate alpha}</span><span class='hs-layout'>(</span></a><span class='hs-comment'>-</span><a class=annot href="#"><span class=annottext>{VV : a | VV == alpha}</span><span class='hs-varid'>alpha</span></a><span class='hs-layout'>)</span><span class='hs-layout'>)</span> <a class=annot href="#"><span class=annottext>{v : (Data.Vector.Vector (Internal.Matrix.Matrix a)) | 0 &lt;= vlen v}</span><span class='hs-varid'>ds</span></a>
<span class=hs-linenum>102: </span>          
<span class=hs-linenum>103: </span><span class='hs-keyword'>type</span> <span class='hs-conid'>Sample</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-conid'>Vector</span> <span class='hs-varid'>a</span><span class='hs-layout'>,</span> <span class='hs-conid'>Vector</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span>
<span class=hs-linenum>104: </span>
<span class=hs-linenum>105: </span><span class='hs-keyword'>type</span> <span class='hs-conid'>Samples</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Sample</span> <span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span>
<span class=hs-linenum>106: </span>
<span class=hs-linenum>107: </span>
<span class=hs-linenum>108: </span><span class='hs-definition'>backpropOnce</span> <span class='hs-keyglyph'>::</span> <span class='hs-layout'>(</span><span class='hs-conid'>Floating</span> <span class='hs-layout'>(</span><span class='hs-conid'>Vector</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span><span class='hs-layout'>,</span> <span class='hs-conid'>Floating</span> <span class='hs-varid'>a</span><span class='hs-layout'>,</span> <span class='hs-conid'>Numeric</span> <span class='hs-varid'>a</span><span class='hs-layout'>,</span> <span class='hs-conid'>Num</span> <span class='hs-layout'>(</span><span class='hs-conid'>Vector</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span><span class='hs-layout'>,</span> <span class='hs-conid'>Container</span> <span class='hs-conid'>Vector</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>ActivationFunction</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>ActivationFunctionDerivative</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Network</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Samples</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Network</span> <span class='hs-varid'>a</span>
<span class=hs-linenum>109: </span><a class=annot href="#"><span class=annottext>forall a .
(GHC.Float.Floating&lt;[]&gt; (Data.Vector.Storable.Vector a), GHC.Float.Floating&lt;[]&gt; a, Internal.Numeric.Numeric&lt;[]&gt; a, GHC.Num.Num&lt;[]&gt; (Data.Vector.Storable.Vector a), Internal.Numeric.Container&lt;[]&gt; Data.Vector.Storable.Vector a) =&gt;
a -&gt; (a -&gt; a) -&gt; (a -&gt; a) -&gt; (Neuro.Network a) -&gt; [((Data.Vector.Storable.Vector a), (Data.Vector.Storable.Vector a))] -&gt; (Neuro.Network a)</span><span class='hs-definition'>backpropOnce</span></a> <a class=annot href="#"><span class=annottext>a</span><span class='hs-varid'>rate</span></a> <a class=annot href="#"><span class=annottext>a -&gt; a</span><span class='hs-varid'>act</span></a> <a class=annot href="#"><span class=annottext>a -&gt; a</span><span class='hs-varid'>act'</span></a> <a class=annot href="#"><span class=annottext>(Neuro.Network a)</span><span class='hs-varid'>n</span></a> <a class=annot href="#"><span class=annottext>[((Data.Vector.Storable.Vector a), (Data.Vector.Storable.Vector a))]</span><span class='hs-varid'>samples</span></a> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>foldl'</span> <a class=annot href="#"><span class=annottext>(Neuro.Network a) -&gt; ((Data.Vector.Storable.Vector a), (Data.Vector.Storable.Vector a)) -&gt; (Neuro.Network a)</span><span class='hs-layout'>(</span></a><span class='hs-varid'>updateNetwork</span> <a class=annot href="#"><span class=annottext>{VV : a | VV == rate}</span><span class='hs-varid'>rate</span></a> <a class=annot href="#"><span class=annottext>a -&gt; a</span><span class='hs-varid'>act</span></a> <a class=annot href="#"><span class=annottext>a -&gt; a</span><span class='hs-varid'>act'</span></a><span class='hs-layout'>)</span> <a class=annot href="#"><span class=annottext>{v : (Neuro.Network a) | v == n}</span><span class='hs-varid'>n</span></a> <a class=annot href="#"><span class=annottext>{v : [((Data.Vector.Storable.Vector a), (Data.Vector.Storable.Vector a))] | len v &gt;= 0
                                                                            &amp;&amp; v == samples}</span><span class='hs-varid'>samples</span></a>
<span class=hs-linenum>110: </span>
<span class=hs-linenum>111: </span>
<span class=hs-linenum>112: </span><span class='hs-definition'>quadError</span> <span class='hs-keyglyph'>::</span> <span class='hs-layout'>(</span><span class='hs-conid'>Floating</span> <span class='hs-layout'>(</span><span class='hs-conid'>Vector</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span><span class='hs-layout'>,</span> <span class='hs-conid'>Floating</span> <span class='hs-varid'>a</span><span class='hs-layout'>,</span> <span class='hs-conid'>Fractional</span> <span class='hs-layout'>(</span><span class='hs-conid'>RealOf</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span><span class='hs-layout'>,</span> <span class='hs-conid'>Normed</span> <span class='hs-layout'>(</span><span class='hs-conid'>Vector</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span><span class='hs-layout'>,</span> <span class='hs-conid'>Numeric</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-conid'>ActivationFunction</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Network</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Samples</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>RealOf</span> <span class='hs-varid'>a</span>
<span class=hs-linenum>113: </span><a class=annot href="#"><span class=annottext>forall a .
(GHC.Float.Floating&lt;[]&gt; (Data.Vector.Storable.Vector a), GHC.Float.Floating&lt;[]&gt; a, GHC.Real.Fractional&lt;[]&gt; (Internal.Numeric.RealOf a), Internal.Util.Normed&lt;[]&gt; (Data.Vector.Storable.Vector a), Internal.Numeric.Numeric&lt;[]&gt; a) =&gt;
(a -&gt; a) -&gt; (Neuro.Network a) -&gt; [((Data.Vector.Storable.Vector a), (Data.Vector.Storable.Vector a))] -&gt; (Internal.Numeric.RealOf a)</span><span class='hs-definition'>quadError</span></a> <a class=annot href="#"><span class=annottext>a -&gt; a</span><span class='hs-varid'>act</span></a> <a class=annot href="#"><span class=annottext>(Neuro.Network a)</span><span class='hs-varid'>net</span></a> <a class=annot href="#"><span class=annottext>[((Data.Vector.Storable.Vector a), (Data.Vector.Storable.Vector a))]</span><span class='hs-varid'>samples</span></a> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>GHC.Types.Double -&gt; (Internal.Numeric.RealOf a)</span><span class='hs-varid'>realToFrac</span></a> <span class='hs-varop'>$</span> <a class=annot href="#"><span class=annottext>GHC.Types.Double</span><span class='hs-varid'>foldl'</span></a> <a class=annot href="#"><span class=annottext>((Data.Vector.Storable.Vector a), (Data.Vector.Storable.Vector a))</span><span class='hs-layout'>(</span></a><span class='hs-keyglyph'>\</span><a class=annot href="#"><span class=annottext>GHC.Types.Double</span><span class='hs-varid'>err</span></a> <span class='hs-layout'>(</span><span class='hs-varid'>inp</span><span class='hs-layout'>,</span> <span class='hs-varid'>out</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <a class=annot href="#"><span class=annottext>{v : GHC.Types.Double | v == err}</span><span class='hs-varid'>err</span></a> <span class='hs-varop'>+</span> <a class=annot href="#"><span class=annottext>GHC.Types.Double</span><span class='hs-layout'>(</span></a><a class=annot href="#"><span class=annottext>(Data.Vector.Storable.Vector a) -&gt; GHC.Types.Double</span><span class='hs-varid'>norm_2</span></a> <span class='hs-varop'>$</span> <a class=annot href="#"><span class=annottext>{v : (Data.Vector.Storable.Vector a) | v == output net act inp}</span><span class='hs-varid'>output</span></a> <a class=annot href="#"><span class=annottext>{v : (Neuro.Network a) | v == net}</span><span class='hs-varid'>net</span></a> <a class=annot href="#"><span class=annottext>a -&gt; a</span><span class='hs-varid'>act</span></a> <a class=annot href="#"><span class=annottext>{v : (Data.Vector.Storable.Vector a) | v == inp}</span><span class='hs-varid'>inp</span></a> <span class='hs-comment'>-</span> <a class=annot href="#"><span class=annottext>{v : (Data.Vector.Storable.Vector a) | v == out}</span><span class='hs-varid'>out</span></a><span class='hs-layout'>)</span><span class='hs-layout'>)</span> <a class=annot href="#"><span class=annottext>{v : GHC.Types.Double | v == 0.0
                        &amp;&amp; v == D# 0.0}</span><span class='hs-num'>0</span></a> <a class=annot href="#"><span class=annottext>{v : [((Data.Vector.Storable.Vector a), (Data.Vector.Storable.Vector a))] | len v &gt;= 0
                                                                            &amp;&amp; v == samples}</span><span class='hs-varid'>samples</span></a>
<span class=hs-linenum>114: </span>
<span class=hs-linenum>115: </span>
<span class=hs-linenum>116: </span><span class='hs-definition'>tanh'</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Floating</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>a</span>
<span class=hs-linenum>117: </span><a class=annot href="#"><span class=annottext>forall a . (GHC.Float.Floating&lt;[]&gt; a) =&gt; a -&gt; a</span><span class='hs-definition'>tanh'</span></a> <a class=annot href="#"><span class=annottext>a</span><span class='hs-varid'>x</span></a> <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>let</span> <a class=annot href="#"><span class=annottext>{VV : a | VV == tanh x}</span><span class='hs-varid'>s</span></a> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>{VV : a | VV == tanh x}</span><span class='hs-varid'>tanh</span></a> <a class=annot href="#"><span class=annottext>{VV : a | VV == x}</span><span class='hs-varid'>x</span></a>
<span class=hs-linenum>118: </span>           <span class='hs-keyword'>in</span> <a class=annot href="#"><span class=annottext>a</span><span class='hs-num'>1</span></a> <span class='hs-comment'>-</span> <a class=annot href="#"><span class=annottext>{VV : a | VV == tanh x
          &amp;&amp; VV == s}</span><span class='hs-varid'>s</span></a><span class='hs-varop'>**</span><a class=annot href="#"><span class=annottext>a</span><span class='hs-num'>2</span></a>
<span class=hs-linenum>119: </span>
<span class=hs-linenum>120: </span><span class='hs-definition'>loadNetwork</span> <span class='hs-keyglyph'>::</span> <span class='hs-layout'>(</span><span class='hs-conid'>Storable</span> <span class='hs-varid'>a</span><span class='hs-layout'>,</span> <span class='hs-conid'>Element</span> <span class='hs-varid'>a</span><span class='hs-layout'>,</span> <span class='hs-conid'>Binary</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-conid'>FilePath</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>IO</span> <span class='hs-layout'>(</span><span class='hs-conid'>Network</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span>
<span class=hs-linenum>121: </span><a class=annot href="#"><span class=annottext>forall a .
(Foreign.Storable.Storable&lt;[]&gt; a, Internal.Matrix.Element&lt;[]&gt; a, Data.Binary.Class.Binary&lt;[]&gt; a) =&gt;
[GHC.Types.Char] -&gt; (GHC.Types.IO (Neuro.Network a))</span><span class='hs-definition'>loadNetwork</span></a> <a class=annot href="#"><span class=annottext>[GHC.Types.Char]</span><span class='hs-varid'>fp</span></a> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>{VV : forall a . a -&gt; (GHC.Types.IO a) | VV == return}</span><span class='hs-varid'>return</span></a> <span class='hs-varop'>.</span> <a class=annot href="#"><span class=annottext>Data.ByteString.Lazy.Internal.ByteString -&gt; (Neuro.Network a)</span><span class='hs-varid'>decode</span></a> <span class='hs-varop'>.</span> <a class=annot href="#"><span class=annottext>Data.ByteString.Lazy.Internal.ByteString -&gt; Data.ByteString.Lazy.Internal.ByteString</span><span class='hs-varid'>decompress</span></a> <span class='hs-varop'>=&lt;&lt;</span> <a class=annot href="#"><span class=annottext>{v : (GHC.Types.IO Data.ByteString.Lazy.Internal.ByteString) | v == readFile fp}</span><span class='hs-conid'>BS.readFile</span></a> <a class=annot href="#"><span class=annottext>{v : [GHC.Types.Char] | len v &gt;= 0
                        &amp;&amp; v == fp}</span><span class='hs-varid'>fp</span></a>
<span class=hs-linenum>122: </span>
<span class=hs-linenum>123: </span><span class='hs-definition'>saveNetwork</span> <span class='hs-keyglyph'>::</span> <span class='hs-layout'>(</span><span class='hs-conid'>Storable</span> <span class='hs-varid'>a</span><span class='hs-layout'>,</span> <span class='hs-conid'>Element</span> <span class='hs-varid'>a</span><span class='hs-layout'>,</span> <span class='hs-conid'>Binary</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-conid'>FilePath</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Network</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>IO</span> <span class='hs-conid'>()</span>
<span class=hs-linenum>124: </span><a class=annot href="#"><span class=annottext>forall a .
(Foreign.Storable.Storable&lt;[]&gt; a, Internal.Matrix.Element&lt;[]&gt; a, Data.Binary.Class.Binary&lt;[]&gt; a) =&gt;
[GHC.Types.Char] -&gt; (Neuro.Network a) -&gt; (GHC.Types.IO ())</span><span class='hs-definition'>saveNetwork</span></a> <a class=annot href="#"><span class=annottext>[GHC.Types.Char]</span><span class='hs-varid'>fp</span></a> <a class=annot href="#"><span class=annottext>(Neuro.Network a)</span><span class='hs-varid'>net</span></a> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>Data.ByteString.Lazy.Internal.ByteString -&gt; (GHC.Types.IO ())</span><span class='hs-conid'>BS.writeFile</span></a> <a class=annot href="#"><span class=annottext>{v : [GHC.Types.Char] | len v &gt;= 0
                        &amp;&amp; v == fp}</span><span class='hs-varid'>fp</span></a> <span class='hs-varop'>.</span> <a class=annot href="#"><span class=annottext>Data.ByteString.Lazy.Internal.ByteString -&gt; Data.ByteString.Lazy.Internal.ByteString</span><span class='hs-varid'>compress</span></a> <span class='hs-varop'>$</span> <a class=annot href="#"><span class=annottext>{v : Data.ByteString.Lazy.Internal.ByteString | v == encode net}</span><span class='hs-varid'>encode</span></a> <a class=annot href="#"><span class=annottext>{v : (Neuro.Network a) | v == net}</span><span class='hs-varid'>net</span></a></pre>
</body>
</html>